<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<style type="text/css">
body {
    font-family: sans-serif;
    font-size: smaller;
    padding: 10px;
}

svg {
    font-size: 10px;
}

circle.normal {
  stroke-width: 0px;
}

circle.highlight {
  stroke: rgba(0,0,0,1);
  stroke-width: 2px;
}

.normalAnchor {
    font-weight: normal;
}
    
.highlightedAnchor {
    font-weight: bold;
}

.normalSample {
    color: black;
    background-color: white;
}

.highlightedSample {
    color: white;
    background-color: black;
    padding-left: 2px;
}

text {
  pointer-events: none;
}

text.highlight {
  stroke: blue;
  pointer-events: none;
}

text.shadow {
  stroke: #fff;
  stroke-width: 3px;
  stroke-opacity: .8;
}

ul { 
    padding-left:0px; 
}

li { 
    margin-bottom:0.5em; 
    list-style-type:none;
}
</style>
<script src='http://d3js.org/d3.v3.min.js'></script></head>

<body>
<table>
<tr><td><b id="heading" style="float:left">[Heading]</b>&nbsp;&nbsp;<a href='export' style="float:right; text-decoration:none;"></a><br/>
<div id="plotDiv"></div></td><td id='samplesTd' valign='top' style='padding-left:10px; font-size:11px'>Samples</td></tr>
</table>
<script>// Variables in ${} need to be parsed with appropriate values by the code before this script can be run.

// ---------------------------------------------------------------------------------------
// Define data
// ---------------------------------------------------------------------------------------

// Heading for the page
var heading = 'hematlas, celltype';

var points = {};

// List of edge indices. 
//var connectedIndices = [0,8,39,8,52,49,5,48,24,20,52,34,46,13,33,17,42,45,39,48,48,19,39,41,42,34,4,27,9,46,12,33,44,32,30,32,5,37,21,18,2,44,40,43,1,5,12,25,25,49,50,51,39];
//var connectedIndices = [3,1,0];
//var cIndices = [{n1:0, n2:1, c:0.81}]
var connectedIndices = {}};

// Dimension of the svg area to be created.
var w = 1180.4,
    h = 696.1;

// Contains display string for each sample id
//var sampleGroupDictionary = ${sampleGroupDictionary};

// These are used to create a unique id for each point, while not relying on the label used in the point.
var sampleIndices = {};
for(var i = 0; i < points.length; i++) {
    sampleIndices[points[i].label] = i;
}

var labelDistance = 0;

// Define nodes and edges (also called links)
var nodes = [];
var links = [];
for(var i = 0; i < connectedIndices.length; i++) {
    var lineColour = (connectedIndices[i][2]>=0)? '#c6c6c6' : '#ff0000';
    links.push({source:connectedIndices[i][0], target:connectedIndices[i][1], weight:1, color:lineColour});
    //links.push({source:i+1, target:connectedIndices[i], weight:1});
};

// Define labelAnchors and labelAnchorLinks. Note that these are duplicated
var labelAnchors = [];
var labelAnchorLinks = [];
for(var i = 0; i < points.length; i++) {
    labelAnchors.push({
        node : points[i]
    });
    labelAnchors.push({
        node : points[i]
    });
};

for(var i = 0; i < points.length; i++) {
    labelAnchorLinks.push({
        source : i * 2,
        target : i * 2 + 1,
        weight : 1
    });
};


// ---------------------------------------------------------------------------------------
// Define functions
// ---------------------------------------------------------------------------------------

// Handling mouse over and out events (note that this code needs to come before .on calls for circles, otherwise it doeesn't work)
var nodeMouseOverFunction = function() {
    var circle = d3.select(this);   // this selects the circle
    circle.attr("class","highlight");   // change its class to highlight it
    d3.selectAll("#anchorText_"+circle.attr("index")).attr("class","highlightedAnchor");
    d3.selectAll("#li_"+circle.attr("index")).attr("class","highlightedSample");
}

var nodeMouseOutFunction = function() {
    var circle = d3.select(this);
    circle.attr("class","normal");
    d3.selectAll("#anchorText_"+circle.attr("index")).attr("class","normalAnchor");
    d3.selectAll("#li_"+circle.attr("index")).attr("class","normalSample");
}

// ---------------------------------------------------------------------------------------
// Draw using the data
// ---------------------------------------------------------------------------------------

// Set heading for the page
d3.select("#heading").text(heading + " (" + points.length + ")");

// Populate the area with the list of sample ids first, because for large number of these, we increase the height of svg area.
var sampleNode = d3.select("#samplesTd").append("ul").selectAll("li")
    .data(points)
    .enter().append("li")
    .attr("id", function(d, i) { return "li_"+i; })
    .text(function(d) { return d.label; });

// Define the plot area with specified width and height (note that we must convert height attribute to float before using max function).
var vis = d3.select("#plotDiv").append("svg:svg")
    .attr("width", w)
    .attr("height", d3.max([h, parseFloat(d3.select("#samplesTd").style("height"))]))
    .style("border-top", "1px solid grey");


// Create a force layout on the points
var force = d3.layout.force().size([w, h]).nodes(points).links(links).gravity(1).linkDistance(50).charge(-3000).linkStrength(function(x) {
    return x.weight * 10
});
force.start();

// Create a force layout on the labelAnchors
var force2 = d3.layout.force().nodes(labelAnchors).links(labelAnchorLinks).gravity(0).linkDistance(0).linkStrength(8).charge(-100).size([w, h]);
force2.start();

// Draw links first so that nodes are on top
var link = vis.selectAll("line.link").data(links).enter().append("svg:line")
    .attr("class", "link")
    .style("stroke", function(d) {
        return d.color;
    });
var anchorLink = vis.selectAll("line.anchorLink").data(labelAnchorLinks)//.enter().append("svg:line").attr("class", "anchorLink").style("stroke", "#999");

// Add a circle to each node and stylise it
var node = vis.selectAll("g.node").data(force.nodes()).enter().append("svg:g");
node.append("svg:circle")
    .attr("index", function(d,i) {
        return i;
    })
    .attr("r", function(d) {
        return d.radius;
    })
    .attr("fill", function(d) {
        return d.fill;
    })
    .attr("stroke", function(d) {
        return d.stroke;
    })
    .attr("class", "normal")
    .on("mouseover", nodeMouseOverFunction)
    .on("mouseout", nodeMouseOutFunction);

node.call(force.drag);

var anchorNode = vis.selectAll("g.anchorNode").data(labelAnchors).enter().append("svg:g");
anchorNode.append("svg:circle").attr("r", 0).style("fill", "#FFF");
anchorNode.append("svg:text")
    .text(function(d, i) {
        return i % 2 == 0 ? "" : d.node.label
        //return i % 2 == 0 ? "" : sampleGroupDictionary[d.node.label]
    })
    .attr("class", "normalAnchor")
    .attr("id", function(d, i) { 
        return i % 2 == 0 ? "" : "anchorText_"+sampleIndices[d.node.label];
    });
    
var updateLink = function() {
    this.attr("x1", function(d) {
        return d.source.x;
    }).attr("y1", function(d) {
        return d.source.y;
    }).attr("x2", function(d) {
        return d.target.x;
    }).attr("y2", function(d) {
        return d.target.y;
    });

}

var updateNode = function() {
    this.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
    });

}

force.on("tick", function() {

    force2.start();

    node.call(updateNode);

    anchorNode.each(function(d, i) {
        if(i % 2 == 0) {
            d.x = d.node.x;
            d.y = d.node.y;
        } else {
            var b = this.childNodes[1].getBBox();

            var diffX = d.x - d.node.x;
            var diffY = d.y - d.node.y;

            var dist = Math.sqrt(diffX * diffX + diffY * diffY);

            var shiftX = b.width * (diffX - dist) / (dist * 2);
            shiftX = Math.max(-b.width, Math.min(0, shiftX));
            var shiftY = 5;
            this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
        }
    });

    anchorNode.call(updateNode);

    link.call(updateLink);
    anchorLink.call(updateLink);

});
</script></body>
</html>
